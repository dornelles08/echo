
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `Segment` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/library"
import type * as $Enums from "../enums.ts"
import type * as Prisma from "../internal/prismaNamespace.ts"

/**
 * Model Segment
 * 
 */
export type SegmentModel = runtime.Types.Result.DefaultSelection<Prisma.$SegmentPayload>






export type SegmentCompositeListFilter = {
  equals?: Prisma.SegmentObjectEqualityInput[]
  every?: Prisma.SegmentWhereInput
  some?: Prisma.SegmentWhereInput
  none?: Prisma.SegmentWhereInput
  isEmpty?: boolean
  isSet?: boolean
}

export type SegmentOrderByCompositeAggregateInput = {
  _count?: Prisma.SortOrder
}

export type SegmentListCreateEnvelopeInput = {
  set?: Prisma.SegmentCreateInput | Prisma.SegmentCreateInput[]
}

export type SegmentListUpdateEnvelopeInput = {
  set?: Prisma.SegmentCreateInput | Prisma.SegmentCreateInput[]
  push?: Prisma.SegmentCreateInput | Prisma.SegmentCreateInput[]
  updateMany?: Prisma.SegmentUpdateManyInput
  deleteMany?: Prisma.SegmentDeleteManyInput
}

export type SegmentWhereInput = {
  AND?: Prisma.SegmentWhereInput | Prisma.SegmentWhereInput[]
  OR?: Prisma.SegmentWhereInput[]
  NOT?: Prisma.SegmentWhereInput | Prisma.SegmentWhereInput[]
  id?: Prisma.StringFilter<"Segment"> | string
  start?: Prisma.FloatFilter<"Segment"> | number
  end?: Prisma.FloatFilter<"Segment"> | number
  text?: Prisma.StringFilter<"Segment"> | string
  avg_logprob?: Prisma.FloatFilter<"Segment"> | number
  compression_ratio?: Prisma.FloatFilter<"Segment"> | number
  no_speech_prob?: Prisma.FloatFilter<"Segment"> | number
}

export type SegmentUpdateManyInput = {
  where: Prisma.SegmentWhereInput
  data: Prisma.SegmentUpdateInput
}

export type SegmentDeleteManyInput = {
  where: Prisma.SegmentWhereInput
}

export type SegmentUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  start?: Prisma.FloatFieldUpdateOperationsInput | number
  end?: Prisma.FloatFieldUpdateOperationsInput | number
  text?: Prisma.StringFieldUpdateOperationsInput | string
  avg_logprob?: Prisma.FloatFieldUpdateOperationsInput | number
  compression_ratio?: Prisma.FloatFieldUpdateOperationsInput | number
  no_speech_prob?: Prisma.FloatFieldUpdateOperationsInput | number
}



export type SegmentSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  start?: boolean
  end?: boolean
  text?: boolean
  avg_logprob?: boolean
  compression_ratio?: boolean
  no_speech_prob?: boolean
}, ExtArgs["result"]["segment"]>



export type SegmentSelectScalar = {
  id?: boolean
  start?: boolean
  end?: boolean
  text?: boolean
  avg_logprob?: boolean
  compression_ratio?: boolean
  no_speech_prob?: boolean
}

export type SegmentOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "start" | "end" | "text" | "avg_logprob" | "compression_ratio" | "no_speech_prob", ExtArgs["result"]["segment"]>

export type $SegmentPayload = {
  name: "Segment"
  objects: {}
  scalars: {
    id: string
    start: number
    end: number
    text: string
    avg_logprob: number
    compression_ratio: number
    no_speech_prob: number
  }
  composites: {}
}

export type SegmentGetPayload<S extends boolean | null | undefined | SegmentDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$SegmentPayload, S>





/**
 * Fields of the Segment model
 */
export interface SegmentFieldRefs {
  readonly id: Prisma.FieldRef<"Segment", 'String'>
  readonly start: Prisma.FieldRef<"Segment", 'Float'>
  readonly end: Prisma.FieldRef<"Segment", 'Float'>
  readonly text: Prisma.FieldRef<"Segment", 'String'>
  readonly avg_logprob: Prisma.FieldRef<"Segment", 'Float'>
  readonly compression_ratio: Prisma.FieldRef<"Segment", 'Float'>
  readonly no_speech_prob: Prisma.FieldRef<"Segment", 'Float'>
}
    

// Custom InputTypes
/**
 * Segment without action
 */
export type SegmentDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Segment
   */
  select?: Prisma.SegmentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Segment
   */
  omit?: Prisma.SegmentOmit<ExtArgs> | null
}
